use crate::x::{lookup_keysym, Display, Window};
use std::ffi::{c_void, CStr, CString};
use x11::xlib::{
  ControlMask, ShiftMask, XBufferOverflow, XCloseIM, XCreateIC, XDestroyIC, XFree,
  XIMPreeditNothing, XIMStatusNothing, XKeyEvent, XNClientWindow, XNInputStyle,
  XNPreeditAttributes, XNSpotLocation, XOpenIM, XPoint, XSetICFocus, XSetICValues,
  XSetLocaleModifiers, XVaCreateNestedList, Xutf8LookupString, XIC, XIM,
};

/// Special keys, all text is handled through the input management engine.
/// Some of these are still generated from special values in the strings
/// generated by the input engine.
#[derive(Copy, Clone)]
pub enum Key {
  Up,
  Down,
  Left,
  Right,
  Escape,
  CtrlC,
  CtrlA,
  Enter,
  Backspace,
  Delete,
  Home,
  End,
  Tab,
}

pub struct KeyEvent {
  pub key: Key,
  pub is_shift: bool,
  pub is_ctrl: bool,
}

impl KeyEvent {
  pub fn is_text_cursor_movement (&self) -> bool {
    use Key::*;
    match self.key {
      Left | Right | Home | End => true,
      _ => false,
    }
  }
}

type XVaNestedList = *mut c_void;

pub struct InputContext {
  xic: XIC,
  xim: XIM,
  input_buffer: Vec<i8>,
  xn_preedit_attributes: CString,
  spot: Box<XPoint>,
  spot_list: XVaNestedList,
}

impl InputContext {
  fn new (ic: XIC, xim: XIM) -> Self {
    let mut spot = Box::new (XPoint { x: 0, y: 0 });
    let xn_spot_location = CString::new (XNSpotLocation).unwrap ();
    #[rustfmt::skip]
    let spot_list = unsafe {
      XVaCreateNestedList (
        0,
        xn_spot_location.as_ptr (), spot.as_mut (),
        std::ptr::null_mut::<std::ffi::c_void> (),
      )
    };
    Self {
      xic: ic,
      xim,
      input_buffer: vec! [0; 8],
      xn_preedit_attributes: CString::new (XNPreeditAttributes).unwrap (),
      spot,
      spot_list,
    }
  }

  pub fn lookup (&mut self, event: &mut XKeyEvent) -> Option<&str> {
    unsafe {
      let mut sym = 0;
      let mut status = 0;
      let mut c;
      c = Xutf8LookupString (
        self.xic,
        event,
        self.input_buffer.as_mut_ptr (),
        self.input_buffer.capacity () as i32 - 1,
        &mut sym,
        &mut status,
      );
      if status == XBufferOverflow {
        self.input_buffer.resize (c as usize + 1, 0);
        c = Xutf8LookupString (
          self.xic,
          event,
          self.input_buffer.as_mut_ptr (),
          self.input_buffer.capacity () as i32 - 1,
          &mut sym,
          &mut status,
        );
      }
      if c == 0 {
        return None;
      }
      self.input_buffer.set_len (c as usize + 1);
      self.input_buffer[c as usize] = 0;
      let bytes = std::slice::from_raw_parts (
        self.input_buffer.as_ptr () as *const u8,
        self.input_buffer.len (),
      );
      match CStr::from_bytes_with_nul (bytes) {
        Ok (c_str) => match c_str.to_str () {
          Ok (str) => {
            if str.len () == 1 && !is_printable (str.chars ().next ().unwrap ()) {
              None
            } else {
              Some (str)
            }
          }
          Err (error) => {
            eprintln! ("UTF-8 error in input: {error}");
            None
          }
        },
        Err (error) => {
          eprintln! ("Input error: {error}");
          None
        }
      }
    }
  }

  pub fn set_cursor_position (&mut self, x: i32, y: i32) {
    unsafe {
      self.spot.x = x as i16;
      self.spot.y = y as i16;
      #[rustfmt::skip]
      XSetICValues (
        self.xic,
        self.xn_preedit_attributes.as_ptr (), self.spot_list,
        std::ptr::null_mut::<std::ffi::c_void> (),
      );
    }
  }
}

impl Drop for InputContext {
  fn drop (&mut self) {
    unsafe {
      XFree (self.spot_list);
      //XDestroyIC (self.xic);
      //XCloseIM (self.xim);
    }
  }
}

const fn is_printable (c: char) -> bool {
  let c = c as u32;
  !(c < 0x20 || c == 0x7F || (c >= 0x80 && c < 0xA0))
}

pub fn set_locale_info () {
  unsafe {
    let empty_str = &[0i8];
    libc::setlocale (libc::LC_ALL, empty_str.as_ptr ());
    XSetLocaleModifiers (empty_str.as_ptr ());
  }
}

pub fn init (display: &Display, window: &Window) -> InputContext {
  unsafe {
    let mut xim = XOpenIM (
      display.as_raw (),
      std::ptr::null_mut (),
      std::ptr::null_mut (),
      std::ptr::null_mut (),
    );
    if xim.is_null () {
      println! ("Input method set in XMODIFIERS was not found, falling back to internal");
      let modifier_list = std::ffi::CString::new ("@im=none").unwrap ();
      XSetLocaleModifiers (modifier_list.as_ptr ());
      xim = XOpenIM (
        display.as_raw (),
        std::ptr::null_mut (),
        std::ptr::null_mut (),
        std::ptr::null_mut (),
      );
    }
    let xn_input_style = CString::new (XNInputStyle).unwrap ();
    let xn_client_window = CString::new (XNClientWindow).unwrap ();
    #[rustfmt::skip]
    let ic = XCreateIC (
      xim,
      xn_input_style.as_ptr (), XIMPreeditNothing | XIMStatusNothing,
      xn_client_window.as_ptr (), window.handle (),
      std::ptr::null_mut::<std::ffi::c_void> (),
    );
    XSetICFocus (ic);

    InputContext::new (ic, xim)
  }
}

pub fn translate_key (event: &XKeyEvent) -> Option<KeyEvent> {
  use x11::keysym::*;
  let is_ctrl = event.state & ControlMask == ControlMask;
  #[allow(non_upper_case_globals)]
  let key = match lookup_keysym (event) as u32 {
    XK_Up => Key::Up,
    XK_Down => Key::Down,
    XK_Left => Key::Left,
    XK_Right => Key::Right,
    XK_Escape => Key::Escape,
    XK_c | XK_C if is_ctrl => Key::CtrlC,
    XK_a | XK_A if is_ctrl => Key::CtrlA,
    XK_Return => Key::Enter,
    XK_BackSpace => Key::Backspace,
    XK_Delete => Key::Delete,
    XK_Home => Key::Home,
    XK_End => Key::End,
    XK_Tab => Key::Tab,
    _ => return None,
  };
  Some (KeyEvent {
    key,
    is_shift: event.state & ShiftMask == ShiftMask,
    is_ctrl,
  })
}
